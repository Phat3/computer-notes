SISTEMI EMBEDDED

---------------------- PANORAMICA ----------------------

sistemi embedded: struttura di supporo al funzionamento di un applicazione con molta interazione con l'ambiente esterno in cui
				  i comandi non sono necessariamente immessi dall'utente umano, ma spesso da sensori e possono derivare da
				  dati.
				  anche l'output non deve essere necessariamente sotto forma di interfaccia grafica ma può essere costituito solo
				  da un insieme di segnali.
				  
l'uso dei sistemi embedded si ha quando bisogna far girare una sola applicazione altamente specializzata,
e questo aspetto fa si che posso molto ottimizzare il codice in base al microcontrollore scelto, così da abbassare i costi finali

parametri da valutare in fase di progettazione: - Volumi: volumi della produzione finale
														  se ne produco molti è meglio valutare di creare un circuito stampato ad hoc
														  
												- Interfacce di comunicazione: valutare cosa è utile e cosa è superfluo
												
												- Interfacce utente: valutare se crearla ad hoc o riusare una gia esistente
												
												- Consumo energetico
												
												- time to market: scegliere i vomponenti giusti al monìmento giusto
																  non è detto che la soluzione a costo minore sia la migliore
																  (altre aziende potrebbero aver già introdotto quella stessa tecnologia
																  anni addietro)
												
												- tempo di vita del prodotto
												
4 principali contesti applicativi: - infrstrutture: ponti, autostrade ecc.. 
(tutte queste aree hanno forti									
vincoli implementativi)			   - sistemi nomadici: animali, persone ecc...
								   
								   - spazi privati: abiatazioni, edifici ecc..
								   
								   - sistemi industriali: aerospaziale, medicale ecc..
								   
i sistemi embedded devono essere progettati in modo da rispettare iseguenti aspetti:

	- Affidabilità: il sistema deve avere una bassa probabilità di guasto
	
	- Manutenibilità: il sistema deve essere facilmente riparato
	
	- Disponibilità: deve essere sempre funzionante
	
	- Sicurezza: deve essere immune dal leaking delle informazioni
	
	- Safety: a fronte di n guasto non deve provocare danno alle persone che lo usano
	
la prima fase di progettazione è detta "System Design", in questa fase si cerca di stimare i costi e le performance che deve avere
l'applicazione cosi da scegliere opportunamente i componenti da usare

bisogna integrare bene eterogeneità e costruttività:
	
	- eterogeneità: costruire un sistema utilizzando componenti con funzionalità differenti tra loro(eterogenei)
	
	- componibilità: costruire un sistema componendo blocchi più piccoli dalle funzionalità note, quindi progettare interfacce tra i vari componenti
	
	

---------------------- ARCHITETTURA E PROGETTAZIONE ----------------------	 
	
l'attività di progettazione è divisa in 4 fasi: - definizione dell'architetture
												- partizionamento in hardware software e comunicazione
												- implementazione hardware software e comunicazione
												- produzione

anche i progettisti più esperti si avvalgono di metodi empirici in fase di progettazione

3 tipi di soluzioni architetturali: - 1 - PCB(printed circuit board): tutti i componenti sono assemblati sulla board
								   	- 2 - SoC(system on a chip): tutti i componenti sono su un unico chip
								   	- 3 - sistemi distribuiti: la parte computazionale e di dati non risiede su un singolo sistema ma su più sottoinsiemi

1 - PCB: componenti utilizzati: - componenti discreti: resistenze transistor condensatori ecc...

								- alimentazione: ciò che alimenta tutto il sistema.
												 ci s avvale di sequencer ( non molto utili a bassi voltaggi perchè introducono molti errori)	
												 
								- convertitori e filtri: ACD,DAC 
								
								- componenti elettro-ottici: si hanno quando il sistema ha a che fare con segnali elettromagnetici e segnali
								                             di natura ottica
								                             
								- componenti a radiofrequenza: antenne ecc..
								
								- display
								
								- sensori
								
		  una volta scelti i componenti bisogna scegliere il package in cui racchiuderli
		  ne esistono di 3 tipi: 
		  				 
		  				 - plastica: mediamente economico e offre buone caratteristiche come una buona dissipazione termica
		  		
		  			     - metallo/ ceramica: costosi ma offrono ottime caratteristiche
		  
		  			     - resina: molto economica, si usa solo nei sistemi a bassissimo budget
		  			     
		  inoltre i package differiscono anche dal : 
		  				 
		  				 - tecnica di montaggio: possono essere a buco forato(pin saldati sulla faccia opposta)
		  				 						 oppure ad montaggio superficiale (pin saldati sulla stessa faccia del componente)
		  				 						 
		  				 - posizionamento dei pin: possono essere solo su 2 lati, su 2 lati e con pin più piccoli, su tutti e 4 i lati oppure su tutta 
		  				 						   la superficie sottostante
		  				 						   
		  ci sono 3 componenti fondamentali che formano un PCB:
		  
		  				- materiale conduttore: spesso rame
		  				
		  				- materiale isolante: spesso resina di vetro 
		  				
		  				- materiale adesivo: unisce gli altri 2 strati, pre preq
		  				
		  fabbricazione PCB: 1 - si stende una lastra di materiale isolante e subito sopra viene fissato il ame
		  					 
		  					 2 - si tracciano le piste con del materiale fotosensibile attraverso una tecnica di fotolitografia
		  					 
		  					 3 - con materiali chimici e acidi appositi si rimuove il rame in eccesso e il materiale fotosensibile
		  					 
		  					 4 - vengono uniti più strati attraverso il materiale adesivo
		  					 
		  					 5 - si fora la scheda per creare gli spazi per i pin:
		  					 		
		  					 		3 tipi di fori: - passanti(da parte a parte)
		  					 						
		  					 						- ciechi(il foro non sbuca dall'altra parte)
		  					 						
		  					 						- interni
		  					 
		  					 6 - si deposita una sottile patina isolante sulla superficie esterna della board
		  					 
		  	una volta finita la progettazione si passa alla fase di testing, l'idea che sta alla base è quella di misurare la resistenza tra 2 componenti 
		  	del circuito: se questi in fase di progetto erano in contatto allora si avrà una bassissima resistenza mentre  se erano disgiunti si avrà una resistenza
		  	altissima.
		  	ci sono 2 supporti per il testing: - letto di chiodi: tantissimi probe che iniettano corrente nei punti desiderati
		  									   - flying-probe: pochi probe ma che si spostano di precisione sui componenti della board da testare
		  									   
		  	la maggior problematica che sorge quando si progetta un PCB è l'integrazione tra i componenti, infatti molto spesso capita che i componenti siano molto
		  	eterogenei tra di loro.si pò ovviare a questo problema facendo il pinout dei componenti in fase di partizionamento del sistema
		  	
		  	altre problematiche : - latenza tra le piste di comunicazione e le comunicazioni all'interno dei singoli componenti
		  					 
			boundary scan: tecnica di testing che collega tutti i pin con una sequenza di flip flop e multiplexer.
						   tutti i pin sono collegati da un unico grande registro sequenziale a scorrimento detto scan chain, e questo permette di portare e osservare 
						   l valore logico su ciascun pin
						   

-SoC: vantaggi: - costo unitario: diminuisce il costo dei componenti necessari ma si alza notevolmente il costo di progettazione( ha senso solo in caso di elevate produzioni)
				
				- prestazioni: integrando tutto all'interno del singolo chip si eliminano le poste di interconnessione che provocavano una grande latenza nelle comunicazioni
				
				- sicurezza: è molto più difficile effettuare del reverse engineering sulla struttura di un Soc rispetto ad un PCB 
				
				- assorbimento energetico: si ha un minore assorbimento energetico integrando tutti i componenti su singolo chip
				
				- ingressi/ uscite
				
				
	 componenti: - uno o più microprocessori
	 
	 			 - memorie SRAM o DRAM, rom , flash ecc..
	 			 
	 			 - filtri, decoder ecc..
	 			 
	 			 - blocchi di temporizzazione
	 			 
	 			 - blocchi digitali specifici per l'applicazione
	 			 
	 			 - blocchi di alimentazione
	 			 
	 			 - interfacce analogiche, convertitori ecc..
	 			 
	 come nelle PCB il primo passo in fase di progettazione è il partizionamento del sistema, il secondo passo invece è decidere l'allocazione delle risorse sui vari
	 componenti di calcolo.
	 infine il terzo passo è decidere l'allocazione della memoria; ci sono 2 tipi di possibilità:
	 
	 			- memoria centralizzata: semplifica la comunicazione dei dati tra i vari componenti essendo tutta accentrata in un unico punto, ma si creano molti 
	 									conflitti nell'accesso ai dati. è necessario introdurre un arbiter degli accessi
	 									
	 			- memoria decentralizzata: è una piccola parte di memoria locale ad ogni componente, si complica di molto il problema delle comunicazioni tra i vari componenti
	 			
	 a seconda dell' approccio scelto si deve decidere il sistema di comunicazione appropriato tra bus gerarchici e NoC
	 
	 il test viene eseguito fin da subito in fase di progettazione grazie a moduli creati ad hoc che vengono affiancati al chip
	 
	 boundary partial scan: le catene coinvolgono parte dei registri del chip, inoltre la catena non tocca solo i punti di comunicazione co l'esterno ma anche la logica interna
	 						 per poter configurare questa catena si usa il controller TAP che interpreta un semplice protocollo formato da comandi di configurazione.
	 						 il più noto è il JTAG
	 						 
	 BIST: creata per ovviare al grande onere computazionale di creare vettori di test significativi da dare in pasto al boundary scan.
	 	   si possono generare i 2 modi queste sequenze: - test esaustivo: provo tutte le possibili combinazioni di ingresso
	 	   												 - test pseudo-esaustivo:suddivido gli ingressi in gruppi e ne testo solo quelli significativi
	 	   												 
	 	   												 
- Sistemi distribuiti: la topologia di rete in una Wis è fortemente dinamica e riconfigurabile
					   una Wis è formata da tre componenti fondamentali: - Host
					   													 - Gateway
					   													 - canale di comunicazione tra host e gateway
					   													 
					   	approccio alla progettazione: - modello del sistema: bisogna decidere se fare un modello basato sui nodi o sui componenti.
					   														  il primo si focalizza maggiormente sull'aspetto fisico del sistema mentre
					   														  il secondo si focalizza sull'aspetto astratto dividendo il sistema in funzionalità
					   														  un altro aspetto da decidere è come bilanciare la computazione, se farla locale o 
					   														  decentralizzata
					  					 			  
					  					 			  - architettura hardware dei nodi: decidere il microprocessore, il chipset di comunicazione e il bus interno
					  					 			  
					  					 			  - architettura software: decidere se implementare o meno un SO
					  					 			  
					  					 			  - modello di programmazione
					  					 			  
					  					 			  - protocolli: come devono comunicare i vari nodi( bluetooth ecc..)
					  					 			  
					  					 			  - architettura di rete: piatta o gerarchica e centralizzata o decentralizzata
		  					 
progettare un sistema embedded dal nulla, pur avendo chiara l'architettura e l'applicazione finale è difficile anche per progettisti esperti, inoltre l'onere computazionale
per avere un bon caso di est è molto significativo ed è per questo che ci si avvale di piattaforme di prototipazione per risolvere il problema, e queste sono:
		
		- sistemi di emulazione digitali semplici: sono FPGA e permettono di emulare sistemi semplici con porte standard
		
		- sistemi di emulazione digitali complessi: sono FPGA che permettono di emulare sistemi e si possono controllare anche alimentazione, porte complesse ecc..
		
		- sistemi di emulazione software
		
		- sistemi di emulazione software/hardware
		
		- sistemi di emulazione application specific
		
		- sistemi di emulazione di SoC
		
approccio alla progettazione con board di prototipazione: 1 - analis dei requisiti
															
														  2 - scelta ella piattaforma: si cerca di trovare la piattaforma più simile a quella reale e posibilmente
														  							   estendibile
														  							   
														  3 - reperimento sdk: occhio ai tempi!
														  
														  4 - progettazione
														  
														  5 - realizzazione del prototipo
														  
														  6 - verifica



---------------------- FLUSSO DI PROGETTAZIONE ----------------------


flusso di progettazione: fase che va dalla creazione puramente formale del sistema fino alla fabbricazione(esclusa) e comprende:

			- specifica a livello di sistema
			
			- descrizione architettura 
			
			- progettazione 
			
			- testing
			
ci si avvale di 3 strumenti fondamentali: - modelli
										  - metriche
										  - strumenti di gestione dei dati 
										  
										  
- modelli: rappresentazione formale del sistema che specifica alcuni aspetti e ne ignora altri a seconda dello step a cui il modello si riferisce. non deve essere ambiguo e deve 
		   essere semanticamente corretto e chiuso per fornire un adeguato supporto all'elaborazione
		   
		   un modello può essere diverso a seconda degli obiettivi a cui punta: - esplorazione architetturale: cerca di individuare una gusta architettura su cui sviluppare
		   (DIPENDENTI dal dominio applicativo software/hardware)			    - valutazione prestazioni: stime che deve rispettare il modello finito
		   																		- sintesi: sintesi di tutte le funzioni del sistema che andranno raffinate tramite un strumento automatico
		   																				   (es: modello c++ viene compilato in assembly)
		   																		- analisi funzionale: cattura le funzionalità del sistema,spesso deve essere eseguibile per avere senso
		   																		- validazione e verifica: utilizzati in fase di verifica,
		   																								  specificano i casi di test e devono essere eseguibili
		   																		- mapping: mappano le funzionalità del sistema con i vari componenti
		   																		- placement e routing: descrizione FISICA di come vanno posizionati i vari componenti e come devono 
		   																							   comunicare
		   																		
		   																	
			un modello ha anche una serie di proprietà indipendenti dal dominio applicativo, ma date dal processo che sta sotto il calcolo modello(semantica), queste possono essere:
						 
						 - interpretazione del tempo: - continuo
						 							  - discreto
						 							  - event driven(il tempo scatta quando avviene un evento) -> utile nelle simulazioni in cui si è in uno stato stabile per molto tempo
						 							  															  (abbasso il costo di simulazione)
						 							  															  nel modello time driven lo stato viene ricalcolato ad ogni scatto 
						 							  															  di tempo anche se lo stato non cambia 
						 							  - time driven( il temp scatta ad intervalli prefissati)							  		
			
						 - natura: - deterministico
						 		   - non deterministico
						 		   - stocastico(non deterministici e con almeno una variabile aleatoria)
			
			ci sonno diversi livelli di astrazione e variano a seconda del dominio applicativo:
					
					     - software: - sistema: descrizione astratta del sistema attraverso diagrammi UML ecc
					     			 
					     			 - algoritmico: si descrivono e implementano le funzionalità tramite linguaggi di programmazione ad alto livello
					     			 				(troppo astratto in ambito embedded senza creare modelli sottostanti)
					     			 
					     			 - dataflow/logico: si scindono le funzionalità del livello algoritmico in funzioni elementari(assembly)
					     			 
					     			 - fisico: file binari(coincide con il prodotto finito)
					     			 
					     - hardware: - sistema: descrizione astratta del sistema attraverso diagrammi UML ecc
					     
					     			 - algoritmico: molto poco utile in hardware(livello di astrazione troppo alto)
					     			 
					     			 - dataflow: descrizione specifica di ogni componente hardware, della dimensione dei blocchi di memori ecc... attraverso linguaggi descrittivi(VHDL)
					     			 
					     			 - logico: descrizione del sistema in modo non ambiguo tramite la descrizione di blocchi logici elementari
					     			 
					     			 - fisico: descrizione dell'hardware dal punto di vista chimico/fisico e geometrico
					     			 

- metriche: misurazione della qualità del sistema
			
			date diverse grandezze misurabili del sistema( ritardo, tempo di esecuzione ecc.) attraverso una funzione matematica, grazie al suo risultato,
			è possibile stimare la qualità del sistema 	
			
			divisione di metriche: - prestazioni: principalmente tempo di esecuzione e ritardo
												  
												  - software: numero di cicli di clock, tempo per rientrare da una interrupt ecc..
												  
												  - hardware: latenza, frequenza di clock ecc..
												  
								   - dimensioni: - software: - dimensioni statiche: dimensioni del codice, ci identifica quanta memoria non volatile devo possedere nel mio sistema
								   							
								   						   	 - dimensioni dinamiche: date dalla grandezza dello stack e dell'heap che si formano durante l'esecuzione, identificano
								   						   						     quanta RAM montare	
								   				 
								   				 - hardware: numero di transistor, look up table, die size ecc...(in digitale numero di equivalent gate)
								   				 
								   - potenza: potenza dissipata dal sistema, spesso si ricorre a stime medie oppure alla potenza dinamica in fase di switch
								   
								   - testabilità: si testa la coperture della rete cioè quanti guasti ho in percentuale durante la fase di testing
			
			le metriche devono essere OBBLIGATORIAMENTE eseguibili
			
- strumenti: molto utili data la complessità sempre maggiore dei sistemi

			 vengono differenziati in base al: - dominio di applicazione
			 									
			 								   - livello di astrazione
			 								   
			 								   - funzionalità svolte
			 
			compilazione e sintesi: strumenti che partendo da un modello con astrazione maggiore ne producono uno con astrazione minore	
									
									es: UML -> java: code generator
										
										c++ -> assembly: compilatore	
										
			verifica: strumenti che verificano che il modello rispetti veramente le specifiche
			testing	  la verifica in abito software viene principalmente effettuato facendo girare il software ottenuto sull'architettura che lo deve ospitare,
					  se non è disponibile l'architettura si usano le instruction set dell'architettura su un altro sistema( spesso insieme all'instruction set è fornito anche il debugger)
					  si può fare verifica anche con profiler e i tool di code coverage	
					  
					  sul piano hardware la verifica si basa tutta sulla simulazione: - simulatori logici digitali: simulano il circuito e il funzionamento delle porte logiche (VHDL)
					  																  
					  																  - simulatori elettro analogici: risolvono le equazioni che governano il sistema (SPICE)
					  
					  una volta	ultimata la fase di produzione si passa al testing.
					  in ambito software coincide con la fase d verifica mentre in ambito hardware assume un ruolo molto importante.
					  lo scoglio più grande è generare sequenze di input utili e significative per il caso di test( si usano le tecniche descritte al capitolo 2)
					  
attraverso tutti questi strumenti modelli e metriche è possibile delineare un flusso di sviluppo del sistema:

	1 - descrizione generale: descrizione delle funzionalità ignorando tutti gli aspetti implementativi e i domini di appartenenza e l'architettura su cui si baserà il sistema
	
	2 - estrarre dalla descrizione generale varie metriche per delineare un po i componenti del sistema(partizionamento)
	
	3 - illustrare il sistema hardware, il software e le interfacce di comunicazione	
	
			-3.hardware: illustrare attraverso il VHDL 	i moduli e i datapath
			
			-3.software: sviluppo di sorgenti
			
			-3.comunicazione: diviso tra hardware(bus ecc..) e software(driver)	
			
			
			
---------------------- TECNOLOGIE HARDWARE ----------------------	

le tecnologie hardware consentono di realizzare circuiti  analogici o digitali e sono oggetto della progettazione hardware

4 principali tipologie: - COTS: componenti specifici che svolgono una specifica funzione, possono essere acquistati ed assemblati direttamente sulla board
						
						- Microprocessore: utile quando il problema da implementare è risolvibile via software
						
						- Logiche programmabili: molto flessibili dal punto di vista hardware, offrono molte porte logiche bistabili ecc..
						
						- ASIC: componenti hardware che svolgono una sola operazione, massimizzano le prestazioni e minimizzano i consumi, molto costosi
						
processo planare: principale processo di produzione degli ASIC.
				  si parte da 2 importanti assunzioni di base:  - si parte da un semiconduttore( quasi sempre il silicio)
				  												- tutti i componenti che formano un circuito integrato possono essere creati con il semiconduttore scelto
				  
				  3 importanti componenti: - materiale conduttore: spesso finissime piste di rame
				  						   - silicio n: alta conducibità
				  						   - silicio p: bassa conducibilità
				  						   - isolante: ossido di silicio
				  						  
				  processo: 1 - si parte da un wafer di silicio
				   			 
				   			2 - deposizione: si cosparge il wafer con del materiale photoresist, con proprietà di monomero se investito dalla luce
				   			
				   			3 - mascheramento: si illumina il wafer con una maschera che disegna le varie piste del circuito
				   			
				   			4 - lavaggio: si toglie il photoresist in eccesso tramite agenti chimici
				   			
				   			5 - p-well: si droga un area ampia a silicio p
				   			
				   			6 - base: si opera un'altra operazione di deposizione, lavaggio, e maschramento nella zona p-well per stampare le zone che andranno drogte n
				   			
				   			7 - emettitore e collettore: si fa la stessa cosa di sopra però drogando p
				   			
				   			8 - ossidazione: si deposita uno strato di ossido di silicio su tutto il wafer
				   			
				   			9 - mascheramento isolante: si opera una nuova operazione di mascheramento per marcare le zone di isolante da rimuovere
				   			
				   			10 - lavaggio isolante: tramite un bagno acido rimuovo le parti di isolante in eccesso
				   			
				   			11 - deposito conduttore: deposito il rame che andrà a creare i contatti dei vari componenti
				   			
				   			12 - rimozione conduttore
				   			
				   			13 - fabbricazione interconnessioni: vengono creati più strati di materiale isolante e conduttore e per ogni strato si crea una singola pista di interconnessione
				   			
il processo planare funziona bene nei circuiti di piccole dimensioni, quando lo si vuole applicare a circuiti di grandi dimensioni la sua efficacia e flessibilità
sparisce 
si usano 3 processi per ovviare a questo problema(questi processi lasciano al progettista il compito di assemblare i vari componenti): 

		- standard cell: si alza il livello di astrazione da singolo transistor a cella.
						 una cella è un insieme di tutti i componenti base che servono già pre assemblati, possono essere complesse con flip-flop, bistabili ecc
						 le celle devono essere disposte in manera rigida sulla board e devono avere determinate caratteristiche:
						 
						 		- devono avere tutte la stessa altezza: facilita il piazzamento
						 		
						 il piazzamento sul chip segue queste regole:
						 		
						 		- 3 zone: - pad-ring: ospitano il pad del chip, a loro volta divise in I/O site o pad site
						 					
						 				  - row: ospitano la logica funzionale, divise in core site
						 				  
						 				  - channel: ospitano i canali d interconnessione
						 
						 anche al loro interno le celle devo seguire una precisa geometria che identifica per esempio dove piazzare i p-mos e n-mos
						 i vdd rail e i vss rail sono interni ad ogni cell
						 
						 le celle sono identificate da: - nome
						 								- funzionalità
						 								- proprietà non funzionali
						 								- numero, nome e posizione dei pin
						 								- angolo di posizionamento
		
		- gate array / sea of gate: si parte da un wafer di silicio parzialmente fabbricato( ci sono tutti i transistor) separati da canali di routing
									se le interconnessioni sono fatte sopra le celle si parla di sea of gate
									i vdd rail e i vss rail sono ai bordi del chip
									
		- full custom: si lascia al progettista massima libertà, molto complesso, si preferisce partire da macrocelle
		
		
per semplificare il processo di progettazione si usano logiche programmabili, che sono circuiti già interamente fabbricati e in cui le interconnessioni e i componenti possono essere
configurati

ne esistono 3 tipi di PLD: - one-time programmable: programmabile solo una volta, applico alte tensioni per modificare la struttura di piccolissime aree

						   - programmabile: posso riprogrammarle con una sequenza opportuna di bit
						   
						   - riconfigurabile: posso riprogrammabile anche senza dover spegnere il circuito
						   

le PLD hanno molto spesso una struttura regolare a matrice,e la loro unità fondamentale è la lookup table(componente in grado si eseguire una qualsiasi funzione logica a 4 ingressi)
le celle possono essere posizionate secondo 2 schemi: - distribuite: interconnessioni e calle sono equamente distribuite su tutta la board
																	 (formano le FPGA)
																	 
													  - accentrate: si acccentrano molte celle in un area ristretta e si lascia lo spazio per le interconessioni nella restante area
													  				(formano le CPLD)						 		
													  				
le interconnessioni possono essere di 4 tipi: -connessioni globali: attraversano tutto il chip e si collegano a molti blocchi logici, introducono molti ritardi
											
											  - connessioni locali: collegano solo blocchi logici vicini, perdo in prestazioni quando devo collegare blocchi logici lontani
											  
											  - connessioni gerarchiche: un misto tra le prime 2
											  
											  - programmable switch matrix: n pin di ingresso e n pin di uscita che possono essere collegati tra di loro in maniera indipendente
											  
i primi dispositivi programmabili furono le PLA e le PLA, erano board con distribuzione accentrata e permettevano di realizzare solo circuiti combinatori.
si è introdotto prima dei buffer di uscita flip flop e multiplexer e questo ha trasformato le PLA/PAL in GAL

CPLD: array di GAL connessi tra di loro da un bus



---------------------- MICROPROCESSORI ----------------------
				   	 
Le soluzioni software sono molto più generiche rispetto alle soluzioni hardware ma le soluzioni hardware sono più difficili da implementare.

il progettista deve scegliere il tipo di processore distinti in: - GPP : processori general purpose, non molto ottimizzati ma flessibili a varie implementazioni

																 - ASP : processori che svolgono un unica funzione			   			

inoltre deve scegliere in che forma acquistarlo, se in forma COTS(forma fisica) oppure IP(descrizione intellettuale)

ci sono altri vari fattori da considerare inoltre: - prestazioni: misure basate sui istruzioni per ciclo di clock, MIPS(million operation per second) MFLOPS, bisogna pero contestualizzarle.
																 ci si avvale anche di altre misure non funzionali come la potenza dissipata
																 
												  - memoria: 2 parametri fondamentali: capienza e banda passante
												  
												  - ambiente di sviluppo: valutare come avviene la compilazione e i software di analisi
												  
												  - packaging: come è strutturato il packaging se incluso
												  
												  - software: quante librerie ha a disposizione quell'architettura e se eventualmente è presente un S.O
												  
												  - periferiche: valutare se serve avere un microprcessore(pura unita di calcolo( che lascia libertà al progettista di scegliersi le sue periferiche,
												  				 oppure un microcontrollore( chip + periferiche già assemblate)
												  				 
-GPP: utili nelle applicazioni che hanno bisogno dell'interazione con l'uomo per funzionare.
		
	  2 fondamentali categorie: - CISC: i primi esemplari di processori sono nati con questa filosofia.
	 								    si è pensato di usare funzioni macchina complesse per ovviare allo scarso quantitativo di memoria.
	 								    queste funzioni macchina complesse inglobano al loro interno le 3 istruzioni fondamentali: load, store, execute
	 								    inoltre si sono arricchite di vari metodi di indirizzamento (assoluto, indiretto, relativo ecc..)
	 								    ci sono istruzioni in grado di operare su più registri contemporaneamente.
	 								    queste istruzioni complesse hanno un elevato costo computazionale, inoltre la lunghezza delle stesse non è fissata ma varia da caso a caso.
	 								    è anche possibile altrare l'ordine delle istruzioni senza cambiare la semantica dell'applicazione(non è detto che le istruzioni siano eseguite nell'ordine ottimale
	 								    a garantirne la massima efficienza).
	 								    per gestire tutto ciò il processore deve avvalersi di complicatissime pipeline a molti stati proprie delle architetture superscalari,
	 								    oppure l'impiego di logiche dedicate proprio dell'approccio out-of-order.
	 								    si può ovviare a questo problema scomponendo le istruzioni complesse in istruzioni elementari ma questo porta di fatto a trasformare un architettura CISC in una RISC quasi.
	 								    	 								    
	 								    inoltre le architetture CISC soffrono di un elevata dissipazione di potenza.
	 							
	 							- RISC: dispongono di un ridotto numero di istruzioni, ridotti tipi di indirizzamento e ridotte operazioni matematiche.
	 									queste istruzioni possono essere condizionali(esegui solo se è avvenuta una condizione prima).
	 									
	 									l'architettura RISC è nata perchè: - i costi delle memorie si sono drasticamente abbassati con l'uscita delle DRAM
	 																	   
	 																	   - hanno tutte tempo di esecuzione quasi fisso e dimensione fissata e questo fa si che il processo di pipelining frutti i suoi massimi benefci
	 																	   
	 									sono dotate di un gran numero di registri divisi solitamente per scopo, questo grande numero riduce il memory spill(salvare il dato di un registro in memoria percheè ho finito i registri a disposizione)
	 									
	 									tutte le operazioni si compongono delle 3 operazioni fondamentali load, store , execute.
	 									
	 									quasi non necessitano di gestione hardware dei conflitti della pipeline grazie all'estrema semplicità delle istruzioni( si possono usare architetture EPIC o VLIW, che spostano questo compito al compilatore)
	 									
	 									la loro dissipazione di potenza è molto più bassa rispetto alle CISC
	 									
- ASP: molto utilizzati in ambito embedded
		
	   i più famosi sono i DSP: ASP che si occupano di elaborazione numerica 
	   							
	   							istruzione fondamentale: z[t+1] = z[t] + x*y
	   							
	   							devo ottimizzare al massimo le istruzioni di somma e prodotto
	   							
	   							sono composti da cicli(altrimenti non avrei il concetto di iterazione precedente e successiva), questi cicli sono molto semplici e di solito la variabile
	   							di controllo del ciclo non viene alterata dentro lo stesso e l'accesso ai dati utilizzati è regolare.
	   							
	   							questi ASP non si avvalgono di ALU ma di un sommatore hardware che prende i dati da un registro circolare(visto che l'accesso ai dati è regolare)
	   							
	   							l'accesso ai dati deve essere estremamente efficiente: i vari componenti all'interno dei core sono collegati da bus molto efficienti e con una grande banda
	   							mentre per la memoria si è optato per l'utilizzo di una cache gerarchica:
	   							
	   									- standford: cache L0 con molta banda, cache L1 con media banda e memoria centrale, unificate tra istruzioni e dati
	   									
	   									- harvard: cache L0 divisa tra istruzioni e dati, L1 e memoria centrale unificate
	   									
	   									- SHARC: L0 divisa tra istruzioni, dati e costanti visto che generalmente il fattore x o y sono costanti nella formula generale	   							
	   									
	 
	 network processor: dedicati alle infrastrutture di rete, devono svolgere routine semplici, come ricerca di un indirizzo IP in una lookup table, su un enorme quantità di dati.
	 					si basano su architetture RISC e hanno bisogno di una forte parallelizzazione tra i vari componenti.
	 					ogni componente ha affiancato un blocco di RAM che permette di specificare il codice della routine da eseguire.
	 					i componenti sono collegati tra loro a bus ad altissima banda e sono interfacciate ad una memoria molto veloce SRAM.
	 					
	 					il core viene programmato normalmente in C mentre le varie routine sono programmate in assembly oppure mendiante l'aiuto di programi di analisi della sintassi tipo lex.
	 					
	 					
	 microcontrollore: chip con all'interno già delle periferiche installate, fortemente integrate.
	 				   molto adatti a problemi che richiedono una computazione modesta, che si risolvono con algoritmi semplici ma che hanno stringenti vincoli hardware		
	 				   
	 				   
	 				   					
---------------------- COMUNICAZIONE-----------------------	 									
	 								   
- trasmissione seriale: tipo di trasmissione più semplice in assoluto
						i vari tipi di comunicazione seriale differiscono per: - tipo di segnale: può essere: - assoluto: unica linea di comunicazione, ricevente e mandante devono avere una massa comune(livello di riferimento comune)
																			                                  
																			                                  - differenziale: 2 linee di comunicazione 
																			   
																			   - schema di temporizzazione: può essere: - sincrono: i 2 sistemi devono essere costantemente sincronizzati
																			   														ci sono 2 modi di fare ciò: posso avere 2 linee distinte in cui su una mando i dati e su un altra il clock
																			   														oppure cerco di codificare il clock sulla stessa linea dei dati
																			   														
																			   														codifiche: - NRZ(non return to zero): i livelli logici 0 1 sono codificati da segnali basso o alto rispettivamente
																			   																	
																			   																   - manchester: i livelli logici 0 1 sono codificati da transizione da segnale alto a segnale basso
																			   																   
																			   																   - BMC: il livello logico 1 è codificato da 01 o 10 mentre 0 da 00 o 11, ho frequenza doppia rispetto 
																			   																   		  a NRZ 
																			   																	
																			   																   - codifica a blocchi: codifico un blocco di n bit in m bit con m>n
																			   																   
																			   											- asincrono: i dati contengono dei segnali che indicano la sequenza al loro interno 
																			   														
																			   														 4 elementi fondamentali: - start bit: indica l'inizio della sequenza da trasmettere
																			   														 							
																			   														 						  - payload: sequenza da trasmettere
																			   														 						  
																			   														 						  - parity bit: bit per il controllo degli errori
																			   														 						  
																			   														 						  - stop bit: bit che indica la fine della trasmissione
																			   														 						  
						- bus standard: - I2C: utile per far comunicare elementi vicini tra di loro( ha una bassa capacità) 
					   						   si compone di 2 linee: SDL( serial data line ) e SCL ( serial data clock ) 
					   						   al bus sono attaccati vari dispositivi divisi tra master e slave
					   						   solo i master possono trasmettere dati sul bus, mentre gli slave possono trasmettere solo gli ack sul bus.
					   						   l'inizio della trasmissione avviene tramite una start condition (passaggio di SDA da 0 a 1 e SCL fisso a 1) e terminata tramite stop condition( SDA da 1 a 0 e SCL a 1)
					   						   se ho più di un master attaccato al bus ho bisogno di un arbiter che mi regoli le politiche di accesso al bus
					   
										
										- SPI: sistema a bus sincrono composto da 4 linee: - una per il clock (SCLK)
																						   - una per l'output
																						   - una per l'imput
																						   - e una per scegliere lo slave dove trasmettere i dati
																						   
											   in questo bus posso avere un solo master
											   ho un elevato throughput rispetto ai bus I2C
											   
										- CAN: tipo di bus differenziale.
											   non ho bisogno di un arbiter perchè ho il concetto di bit dominante e bit recessivo
											   se ho 2 frame uno con bit dominante e uno con bit recessivo, trasmetto quello con bit dominante e metto in attesa l'altro
											   
											   
- trasmissione parallela: si avvalgono di più linee di dati per la trasmissione di questi
						  
						  vantaggi: - velocità: nel caso ideale la velocità di trasmissione aumenta di un fattore pari al numero di linee parallele
						  						 
						  						problemi: - skev: la velocità massima delle linee è pari alla velocità della linea più lenta per poter garantire la sincronizzazione
						  						
						  								  - crosstalk: interferenze
						  								  
						  			- complessità: gli apparati hardware sono meno complessi di quelli di riconoscimento di segnali seriali	
						  			
						  3 tipi di bus: bus dati, bus di controllo e bus di indirizzamento
						  
						  - meccanismi di sincronizzazione: - strobe: il master comunica con una REQ, sul bus di controllo, allo slave che vuole i dati. lo slave manda i dati sulla linea di dati, e il master li processa
						  
						  									- handshake: come lo strobe solo che lo slave manda gli ack sul bus di controllo
						  									
						  									- strobe/handshake: misto tra i 2, mi avvalgo di un segnale di WAIT invece che di ack
						  									
- trasmissione wireless: si basa tutto sulla modulazione: devo centrare il segnale sulla portante
															
														  - segnale: spettro vero e proprio da trasmettere
														  
														  - portante: sinusoide che identifica il mezzo con cui trasmettere il segnale
														  
						 - modulazione analogica: posso modulare in ampiezza, frequenza e fase
						 
						 - modulazione analogica: la portante è analogica mentre il segnale è digitale		
						 
   
	 								   
---------------------- INTERFACCIAMENTO-----------------------		

interfacciamento: comunicazioni tra componenti facenti parte dello stesso sistema.

problema: si ha nell'accesso alle periferiche in quanto il microprocessore non può sapere a priori quando ci saranno dei dati disponibili da leggere.
		  per ovviare a questo problema si usano 3 vie: polling, interrupt e DMA
		  
un altro problema è l'indirizzamento: come fa il microprocessore ad individuare su che componente mandare i dati?

	3 tecniche per ovviare al problema: - memory mapping: ad ogni componente, sia esso memoria o periferica assegno indirizzi contigui di memoria, così il processore basta che sappia su quali indirizzi scrivere per comunicare con un certo componente
										 
										  la periferica per capire che in dato pacchetto transitante sul bus appartiene a lui può procedere in 2 modi:
										  		
										  		- sempre attiva una routine di riconoscimento dei pacchetti
										  		
										  		- dispositivo esterno che contiene tutta la logica di riconoscimento dei pacchetti e tramite un segnale di chip select identifica il componente interessato
										  		
										- standard I/O: i bus hanno una linea in più sul bus di controllo dove identifico con un segnale se voglio scrivere su un componente I/O
										
										- port maped I/O: i dispositivi di I/O sono collegati direttamente al microprocessore attraverso dei canali dedicati. il processore legge e scrive su questi dispositivi come se fossero normali registri
									
	- polling: metodo che controlla periodicamente un registro di stato di una periferica per sapere se ci sono dati da leggere
			   va a discapito delle performance questo metodo e in particolare quando si devono controllare periferiche con un diverso rate
			   
	- interrupt: metodo asincrono, sono le periferiche stesse che comunicano al processore che ci sono dati da leggere. 
				 per fare ciò le periferiche devono essere collegate direttamente al processorre tramite una linea IRQ e il processore eve avere una linea IRQ per comunicare
				 alla periferica che sta eseguendo la interrupt richiesta
				 
				 gestione interrupt: 1 - ricevere richiesta
				 							
				 						 - singola linea: su INTA ho valore logico a 1 in assenza di richieste. appena me ne arriva una lo setto a 0 impedendo a tutti gli altri di eseguire richieste
				 						 
				 						 - linee multiple: ogni periferica è connessa al processore tramite una propria linea IRQ e INTA. limita di molto l'estendibilità dell'architettura
				 						 
				 						 - priority arbiter: componente esterno al processore che si occupa di gestire la priorità delle richieste di interrupt.
				 						 					 è composto da N linee IRQ/INTa, una per ogni periferica, e da una linea IRQ e INTA che lo collega al processore.
				 						 					 quando riceve più richieste determina quale ha la priorità massima seconda la politica decisa e lo comunica al processore.
				 						 					 questo esegue la routine e notifica l'avvenuta esecuzione all'arbiter che si occuperà di notificare la periferica corretta
				 						 				 						
				 					 2 - decidere se eseguire o meno l'interrupt
				 					 
				 					 3 - salvare il contesto dei processi
				 					 
				 					 4 - reperire la routine di gestione dell'interrupt richiesta
				 					 
				 					 		- fixed interrupt: ad ogni periferica è associata una sola routine di interrupt il cui indirizzo è cablato direttamente nel microprcessore
				 					 		
				 					 		- vectored interrupt: l'indirizzo della routine viene messo sul bus dalla periferica e viene prelevata la routine, in un apposito vettore cablato dentro il microprocessore, con indirizzo uguale a quello passato sul bus
				 					 		
				 					 		- interrupt address table: il vettore delle interrupt risiede in memoria e non nel processore
				 					 		
				 					 		
				 					 
				 					 5 -esecuzione della routine
				 					 
				 					 6 - ripristino e ripresa esecuzione del programma
				 					 
				 					 le interrupt si possono 'mascherare' cioè non farle eseguire, posso fare ciò via software con istruzioni assembler.
				 					 via hardware uso una maschera di bit che può essere interpretata in 2 modi: es: 001101 - maschero le interrupt con priorita <= 13
				 					 																					   - maschero le interrupt proveinenti dalle linee 0, 2 e 3
				 					 																					   
				 					 NMI: interrupt che non possono essere mascherate
				 					 
	- DMA: serve per sgravare il processore da trasferimenti ingenti di dati da periferica a memoria.
			
		   quando il DMA riceve da una periferica un segnale che indica che ho dati da trasferire in memoria, il DMA richiede al processore il controllo del bus e lo tiene fino a che
		   non ha trasferito tutti i dati necessari. in questo tempo l processore è scarico e può eseguire altri compiti.
		   il DMA per operare deve conoscere l'indirizzo della periferica su cui leggere e l'indirizzzo di memoria su cui scrivere. spesso queste informazioni sono cablate all'interno del controller
			
			
---------------------- NETWORK ON CHIP -----------------------
	 																					   
si cerca sempre più di integrare più core in un singolo package per aumentare le prestazioni.

prima, per aumentare le prestazioni si aumentava solo la frequenza ma questa faceva aumentare di conseguenza la potenza dissipata (P = V^2 * C * f).

un aumento eccessivi può portare a 2 conseguenze: - termiche : innalzamento eccessivo della temperatura all'interno del package con conseguente rottura	
												  - potenza: aumentare troppo la potenza richiederebbe ingombranti sistemi di dissipazione
												  
per diminuire la potenza si può abbassare la tensione di soglia ma si è quasi arrivati ad un limite fisico ( dopodichè i transistor non commuterebero più).

abbassare la C è un compito esclusivo dei progettisti dei chip perchè è un paramentro costruttivo

problemi legati al technology scaling: - interconnessioni: al diminuire delle dimensioni dei componenti le interconnessioni hanno sempre lo stesso delay
									   - affidabilità: aumenta la complessità del chip utilizzando transistor sempre più piccoli
															   	 					 
				  
problemi che minano l'affidabilità: - difetti di design hardware/software: con l'aumentare della complessità dei chip aumenta anche il numero di bug.
																		   si può controllare la presenza di bug in 2 modi:
																		   		
																		   		- simulazione: provo tante possibilità di input critiche
																		   		- metodi formali: si costruisce una rappresentazione formale del circuito e lo si valida
																		   		
																		   nella realtà il numero di bug è esiguo rispetto alla complessità perchè i processori fanno sempre le stesse cose
																		   e quindi solo pochi stati interni vengono visitati
																		   
									- guasti transitori: problemi termici o di alimentazione
									
									- guasti permanenti: rottura del chip
									
per rispettare la legge di moore si è introdotto l'uso dei multicore

questi permettono: - maggiore predicibilità delle prestazioni

				   - parallelismo reale
				   
				   - miglior gestione termica/potenza
				   
hanno bisogno però di nuovi metodi di interconnessioni perchè bus, point to point e crossbar all'aumentare di core diventano obsoleti

non posso più spingere su aumento di frequenza e su potenza perchè ho raggiunto lo stato dell'arte( 4 GHz e 100W), oltre rischierei di rovinare il chip

tipi di multicore: differiscono per l'organizzazione di memoria: - shared memory: memoria condivisa tra tutti i componenti, non è gestita dal programmatore
															     - distributed memory: la memoria deve essere gestita dal programmatore
															     
la memoria deve essere coerente: maschera i livelli di cache al programmatore
								 
								 è implementata in 2 modi: - broadcast based: tutti i componenti vedono tutte le richieste nello stesso ordne in cui avvengono, è basata su bus
								 												
								 											  i messaggi sono principalmente di cache miss( non ho il dato richiesto in cache e quindi devo chiedere al processore che lo ha di mandarmelo)
								 											  e di copia datata in cache
								 											  
								 											  una volta che ho un cache miss il memory controller manda in broadcast la richiesta per il dato a TUTTI i processori.
								 						   
								 						   - directory based: si usa una struttura diversa dal bus che può scalare in base con l'aumentare della banda richiesta( reti point-to-point, mesh)
								 						   					  e si usa un protocollo di tipo unicast o multicast e non broadcast
								 						   					  
								 						   					  una volta che ho un cache miss il memory controller manda in unicast la richiesta per il dato al processore interessato.
								
la cache può essere privata(possono esserci più copie del dato) o condivisa(esiste solo una copia del dato)

tipi di NoC: - dirette: ogni nodo ha il proprio switch

			 - indirette: uno switch connette più nodi
			 
			 sono classificate anche in base a varie metriche: - hop-count: numero di hop per connettere 2 componenti
			 												   - diametro rete: numero massimo di hop count per raggiungere 2 componenti della rete
			 												   - grado di interconnessione: numero di link che ogni nodo possiede
			 												   
			 paramentri importanti: - politiche di routing: scegliere collegamenti permessi al fine di evitare deadlock
			 						- switching: usare commutazione di paccheto o di circuito
			 						- arbitration: quali collegamenti scegliere se ne ho più di uno possibile
			 						
			 						
- politiche di routing: - deterministico: data una coppia sorgente-destinazione ho un solo percorso possibile
										  
										  es: XY routing: esaurisco gli spostamenti sulle x e poi sule y, non sfrutto bene la topologia di rete, sono deadlock free
										  
						- oblivious: scelgo il cammino a caso
						- adattivo: scelgo in base allo stato corrente della rete, posso scegliere: - cammino minimo
																									- cammino non minimo: serve per evitare contention
				 
le informazioni sono scambiate nelle NoC tramite messaggi, sono formati da: - pacchetti: contengono head flit, uno o più body flit, e un tail flit
																			- flit: flow control digit
																			- phit: physical digit
																			
2 tipi di approccio per la soluzione flit-based: - wormhole: un solo buffer per ogni ingresso, soffre di head of line blocking

															  architettura formata da: - route computation: decide quale rotta deve prendere il flit esaminato
															  						   - switch allocator: decide su quale link della crossbar trasmettere
															  						   - crossbar: permette la comunicazione di ogni input con tutte le uscite
											     
											     - virtual channel: più buffer per ogni ingresso per i flit (virtual channel)
											     					
											     					hanno un ulteriore stato in ingresso che indica quale virtualchannel scegliere
											     				    
											     	
											     identificativi componenti di un flit: - BW: buffer write, scrivo il flit in un particolare input
											     										
											     									   - RC: route computation, decido che rotta deve prendere il flit, campo presente solo nell'head flit
											     									   
											     									   - VA: virtual channel allocator, decido in quale virtualchannel scrivere il flit, campo presente solo nell'head flit
											     									   
											     									   - SA: switch allocator, risolvo i conflitti sui collegamenti della crossbar
											     									   
											     									   - ST: switch traversal, creo il collegamento fisico tra ingresso e uscita nella crossbar
											     									   
											     									   - RT: route traversal, invio il pacchetto e dealloco il collegamento fisico	   
												
												tipi di pipeline: - classica: flit: |BW|RC|VA|SA|ST|RT|
																			  altri flit rimangono in attesa se ho altri flit che non sono arrivati alla fase di ST, poi posso iniziare a processare quello dopo
																			  
																  - lookahead router: si precalcola la route prima di scrivere il flit nel buffer
																  					  flit: |BW-RC|VA|SA|ST|RT|
																  					  
																  - speculation: le operazioni SA e VA si svolgono in parallelo speculando sul successo di quest'ultima
																  				 flit: |BW-RC|SA-VA|ST|RC|
																  				
																  				
ottimizzazioni NoC: - buffer optimization: viene usato ViChaR che permette di gestire la capienza dei virtual channel in base alla congestione di rete.
											
										   - rete con alto traffico: tanti virtual channel con poca capienza
										   - rete con basso traffico: pochi virtual channel con tanta capienza
										   
					- ottimizzazione di rete: 
					
power management: bisogna garantire performance maggiori cercando di limitare la potenza dissipata
				  con il technology	scaling si sentono molto di più i fenomeni di leakage date dalle correnti parassite, e sono di 3 tipi: - subthreshold leakage
				  																														   - gate leakage
				  																														   - junction leakage	
				  																														   
				  concetti diversi: - energia: integrale della potenza lungo l'asse del tempo
				  					- potenza: potenza istantanea consumata 
				  								
				  							   divisa in: - potenza dinamica: potenza dissipata quando gli elementi del circuito commutano di stato
				  							   								
				  							   								  pot din = pot switching + internal pow
				  							   								 
				  							   								  - potenza di switching: potenza richiesta per caricare/scaricare la capacità da comandare
				  							   								 
				  							   								  - internal power: potenza dissipata quando tutti e 2 i componenti del CMOS sono attivi
				  							   				
				  							   			  - potenza statica: potenza dissipata quando i componenti non stanno commutando di stato
				  							   			  			         
				  							   			  			         data da: - subthreshold leakage: corrente che circola tra drain e source
				  							   			  			         		
				  							   			  			         		  - gate leakage: corrente da gate a substrato
				  							   			  			         		  
				  ho un trade of tra potenza statica e quella dinamica, infatti se cerco di diminuire la potenza di switching abbassando la Vdd ho un peggioramento delle prestazioni perchè influisce sulla Idd,
				  quindi per ovviare a questo problema devo abbassare per forza la Vt ma questo mi fa aumentare la subthreshold leakage
				  
				  tecniche per low power: - diminuire potenza dinamica: - clock gating: spengo il clock a quei componenti in stato di idle
				  														
				  														- multi Vdd: associo STATICAMENTE ad ogni componente la sua Vdd minima per il funzionamento
				  														
				  														- DVSFS: associo DINAMICAMENTE ad ogni componente la sua Vdd minima in base all'operazione da svolgere				  							   			  						
				  							   			  							 
				  						  - diminuire potenza statica: - multi-threshold: si usano blocchi con Vt diverse per ovviare al problema del subthreshold leakage	
				  						  
				  						  							   - power gating: tecnica che consiste nello spegnere le parti di circuito non utilizzate.
				  						  							   					
				  						  							   				   problemi: - perdo lo stato quando spengo una cella, ricostruire lo stato è molto dispendioso: per ovviare a questo problema posso usare tensioni bassissime tali però da non far perdere lo stato al componente da 'spegnere'
				  						  							   				   
				  						  							   				   			 - il tempo di riaccensione mi introduce ritardi considerevoli			  						  							   				   			 	
				  						  							   				   			 
				  						  							   				   			 - devo isolare le uscite del componente spento perchè il loro stato diventa casuale e potrebbe compromettere il funzionamento di altre parti del circuito
				  						  							   				   	
				  						  							   				   posso applicare questa tecnica con 2 gradi di precisione: - fine (fine grain): agisco a livello di singola cella
				  						  							   				   																
				  						  							   				   															 - alto (coarse): posso spegnere intere parti del circuito
				  						  							   				   															 
				  						  							   				   	devo introdurre un controllore che gestisca quali regioni del chip spegnere e i componenti che effettivamente le spengono.
				  						  							   				   	
				  						  							   				   	per spegnere si usano dei MOS che devono avere: - bassa corrente di leakage
				  						  							   				   													- bassa caduta di tensione
				  						  							   				   													- basso tempo di riaccensione
				  						  							   				   													
sistemi di simulazione: - GEM5: simulatore di architetture CPU e di architetture di memoria
								
								posso avare varie caratteristiche: - CPU: - semplici
																		  - dettagliate in-order
																		  - dettagliate	out-of-order
																   
																   - memorie flessibili
																   
																   - moltissimi componenti a disposizione
								
								caratteristiche: - flessibile: posso costruire il sistema con i componenti che voglio
												 - dettaglio: posso andare da un dettaglio ad alto livello fino a scendere a dettaglio di microarchitettura
												 - velocità: è un simulatore a tempo discreto event-driven, posso arrivare a frequenze impensabili nel mondo reale
								
								modalità di funzionamento: - full system: posso simulare un intero sistema operativo con gestione delle interrupt, syscall ecc..
								
														   - syscall emulator: simula solo una determinata applicazione
														   
														   prende un file python di configurazione( specifico modalità di funzionamento e modello i componenti del sistema), e sulla base di questo file parte la simulazione in C++
														   
														   simula solo il necessario essendo event-driven e il tempo è espresso in tick e stabilito un numero di tick per secondo ricavo la frequenza di funzionamento.
														   posso raggiungere al massimo la precisione di 1 tick ogni pico secondo
														   
														   ogni oggetto ha delle poste per comunicare con altri oggetti e i messaggi viaggiano sui collegamenti.
														   
														   esistono 3 tipi di interfacce di trasporto: - funzionale: calcolo solo il risultato di un operazione
														   											   - atomica: simulazione funzionale ma che considera anche cambiamenti interni
														   											   - timing: simulazione a livello microarchitetturale
														   	
														   diversi tipi di CPU simulabile: - simple CPU: CPU senza supporto al multithreading e con una pipeline a 5 stadi
														   								   - detailed CPU: CPU con supporto al multithreading e pipeline variabile
														   								   - checker CPU: CPU di supporto a simulazioni complesse
														   								   
						- McPAT: serve per modellare potenza, area e timing in architetture multicore, viene configurato tramite un file XML dove si specifica: tipo di architettura, parametri componenti e statistiche da attuare
						
						- Orion: come McPAT ma non usa un modelllo timing
				  						  							   				   													
				  						  							   				   															
				  						  							   				   										   				
---------------------- SISTEMI REAL-TIME -----------------------		

le librerie possono essere di 2 tip: - nomelibreria: solo implementazione delle funzioni, permette l'esecuzione del codice che implementa la libreria

									 - nomelibreria-dev: presente sia nomi che implementazioni
									 
le librerie possono essere linkate: - staticamente: inglobo fisicamente il codice della libreria nel mio eseguibile, eseguibile più grosso, tolgo problemi di compatibilità

									- dinamicamente: nel mio eseguibile ho solo una referenza alla libreria, sarà compito della macchina che deve far girare il mio eseguibile il reperire di tali librerie
									
processo di compilazione: 1 - passo al compilatore un file C, i file h e un file di startup

						  2 - il compilatore genera un file .s contenente codice assembly
						  
						  3 - l'assemblatore prende il file .s più eventualmente anche altri file assembly ausiliari
						  
						  4 - l'assemblatore produce un file .o
						  
						  5 - il linker prende tutti i file .o necessari, un  file di startup, e un file .ld denominato linker script, il quale mi indica in che aree di memoria mettere le varie componenti del programma
						  
						  6 - il linker genera il file eseguibile .elf	
						  
Makefile: file che viene letto dal tool make,  composto da: - target: nome della regola da eseguire
															- dipendenze: dipendenze che la regola deve soddisfare per essere eseguita
															- comandi: comandi da eseguire per svolgere la regola	
		  
		  simboli speciali: - $@: riferito al target
		  					- $^: riferito a tutte le dipendenze
		  					- $<: riferito alla prima dipendenza
		  					
		  difficili da scrivere in modo che possano funzionare su macchine diverse, si usano gli autotools
		  
		  autotool: insieme di makefile e script shell che consentono di generare makefile specifico per la macchina utilizzata 
		  
		  			funzionamento: 1 - autoscan: partendo dal source tree genera un template di configurazione
		  							
		  						   2 - integra questo template e crea il file config.in
		  						   
		  						   3.1 - autoconf: partendo da config.in genera un file configure
		  						   
		  						   3.2 - autoheader: integra configure guardando se le librerie necessarie sono presenti o meno sulla macchina
		  						   
		  						   3.3 - automake: partendo da un file Makefile.am, che contiene tutte le dipendenze di base, genera un file Makefile.in
		  						   
		  						   4 - generazione del makefile vero e proprio partendo da configure
		  						   
principali strumenti di debugging: - objdump: permette di vedere un contenuto di un oggetto o eseguibile

								   - gdb
								   
								   - strace: permette di vedere tutte le syscall di un eseguibile
								   
								   - ltrace: traccia tutte le chiamate a librerie del programma
								   
								
---------------------- TESTING -----------------------	

4 fasi di testing: - simulazione: tutti gli elementi del sistema sono simulati
								  si crea prima il modello dell'ambiente e poi quello del sistema
								  
								  3 tipi di simulazione: - one way: si ignora il comportamento del sistema e si prendono in considerazione solo l'input e l'output generato
								  									il sistema viene simulato al computer
								  									 
								  						 - feedback: si considera anche il comportamento dinamico dell'ambiente SIMULANDOLO, possibile solo se si hanno modelli semplici
								  						 
								  						 - prototipazione rapida: il comportamento dinamico dell'ambiente non viene simulato ma è ottenuto direttamente dall'ambente reale
					
				   - prototipazione: alcuni elementi sono simulati altri sono reali ma dei prototipi
				   					 
				   					 si procede a testare il software reale nell'ambiente simulato ( software in the loop ) e poi si testa l'hardware reale nell'ambiente simulato( hardware in the loop )
				   					 
				   					 diversi tipi di testing: - test unità software: legata alla verifica dei singoli componenti software
				   					 						  - test di integrazione software: si verifica come i vari moduli software interagiscono tra loro
				   					 						  - test di integrazione hardware/software: si testa come il software interagisce con l'hardware
				   					 						  - test di integrazione di sistema: si verifica che il sistema si comporti secondo le specifiche
				   					 						  - test di integrazione ambientale: si verifica come reagisce il sistema in particolari condizioni ambientali
				   					 						  
				   
				   - pre-produzione: tutti gli elementi del sistema sono reali	
				   
				   - post-produzione: tutti gli elementi del sistema sono reali e creati con i processi produttivi finali
				   					  serve per capire come tarare la catena di produzione
				   					  
				   					  
---------------------- SENSORI -----------------------	

il compito fondamentale di un progettista sta nella scelta del sensore da utilizzare

deve valutare vari parametri: - che cosa deve misurare
							
							  - come misurarlo (misura diretta o indiretta)	
							  
							  - con quale grado di precisione misurarlo
							  
i sensori possono essere digitali(interruttore) o con output analogici che variano a seconda della grandezza fisica misurata

in un sensore IDEALE l'uscita dovrebbe essere diretamente proporzionale alla grandezza misurata

parametri per valutare un sensore: - sensibilità: fattore moltiplicante sulla grandeza misurata, serve per esaltare le grandezze per renderle compatibili con alcuni ingressi
								   - offset: fattore additivo sulla grandezza da misurare
								   - linearità
								   - riferimento: indica a cosa devono essere rapportate le misure rilevate	
								   - errore
								   - calibratura: specifica ogni quanto ricalibrare il sensore
								   
esempi di sensori: - posizione: si usano dei potenziometri, ovvero resistenze variabili in base alla posizione di un cursore
				   - velocità: si usano sensori di tipo digitale che emettono impulsi a seconda della velocità di rotazione, da questi impulsi si ricava la velocità angolare
				   - temperatura: si ricava la temperatura in base alla tensione letta
				   - mems: componenti micromeccanici a bassissimo costo 